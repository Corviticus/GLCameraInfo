package com.example.cameracheckup

import android.Manifest
import android.app.Activity
import android.content.Context
import android.content.pm.PackageManager
import android.hardware.camera2.*
import android.os.Handler
import android.util.Range
import android.util.Size
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch
import timber.log.Timber
import java.util.concurrent.Semaphore
import java.util.concurrent.TimeUnit
import kotlin.coroutines.CoroutineContext
import androidx.fragment.app.FragmentActivity


class CameraInfo(private val activity: Activity, private val cameraViewModel: CameraViewModel) : CoroutineScope {

    /** Run all co-routines on Main  */
    private val job = SupervisorJob()
    override val coroutineContext: CoroutineContext
        get() = Dispatchers.Main + job


    /** An additional thread for running tasks that shouldn't block the UI */
    // private var mBackgroundThread: HandlerThread? = null

    /** A [Handler] for running tasks in the background */
    // private var mBackgroundHandler: Handler? = null

    /** A [CameraManager] for, well, managing the camera! */
    private var mCameraManager: CameraManager? = null

    /** [CameraManager] will be used to get [CameraCharacteristics] */
    private var mCameraCharacteristics: CameraCharacteristics? = null

    /** ID of the current [CameraDevice] */
    private var mCameraId: String? = null

    /** A reference to the opened [CameraDevice] In this app, this will always be the rear-facing camera. */
    private var mCameraDevice: CameraDevice? = null

    /** [CaptureRequest.Builder] for the camera preview */
    private var mPreviewRequestBuilder: CaptureRequest.Builder? = null

    /** [CaptureRequest] generated by [.mPreviewRequestBuilder] */
    private var mPreviewRequest: CaptureRequest? = null

    /** A [Semaphore] to prevent the app from exiting before closing the camera */
    private val mCameraOpenCloseLock = Semaphore(1)

    /** The aspect ration of the device's screen  */
    private var mAspectRatio: Float = 0f

    private var mFocusCharacteristics: IntArray? = null

    /** Range of supported ISO settings */
    private var mRangeISO: Range<Int>? = null
    private var mMaxISO: Int? = null
    private var mMinISO: Int? = null

    /** Range of supported Exposure Value settings */
    private var mRangeExposure: Range<Long>? = null
    private var mMaxExposure: Long? = null
    private var mMinExposure: Long? = null

    /** Range of supported Exposure Compensation values */
    private var mRangeCompensation: Range<Int>? = null
    private var mMaxCompensation: Int? = null
    private var mMinCompensation: Int? = null

    /** A list of supported preview sizes with aspect ratios that match the native display ratio */
    private var mPreviewSizes = arrayListOf<Size>()
    private var mSupportedPreviewSizes: MutableList<Size> = mutableListOf()
    private var mSupportedCaptureSizes: MutableList<Size> = mutableListOf()
    private var mLargestCaptureSize: Size = Size(0, 0)

    /**
     * This [CameraDevice.StateCallback] is called when the [CameraDevice] changes it's state
     * */
    private val mStateCallback = object : CameraDevice.StateCallback() {

        override fun onOpened(cameraDevice: CameraDevice) {

            mCameraOpenCloseLock.release()
            mCameraDevice = cameraDevice

            mFocusCharacteristics = getFocusCharacteristics()

            // get a list of supported ISO settings and update the CameraFragment view model
            mRangeISO = getSupportedISOValues()
            cameraViewModel.isoValues?.value = mRangeISO
            cameraViewModel.supportsISO.value = (mRangeISO != null)

            // get a list of supported Exposure settings and update the CameraFragment view model
            mRangeExposure = getSupportedExposureValues()
            cameraViewModel.exposureValues?.value = mRangeExposure
            cameraViewModel.supportsEV.value = (mRangeExposure != null)

            // get a list of supported EV Compensation values and update the CameraFragment view model
            mRangeCompensation = getSupportedCompensationValues()
            cameraViewModel.evCompValues?.value = mRangeCompensation
            cameraViewModel.supportsEVComp.value = (mRangeCompensation != null)
        }

        override fun onDisconnected(cameraDevice: CameraDevice) {
            mCameraOpenCloseLock.release()
            cameraDevice.close()
            mCameraDevice = null
        }

        override fun onError(cameraDevice: CameraDevice, error: Int) {
            Timber.e("onError() called")
            mCameraOpenCloseLock.release()
            cameraDevice.close()
            mCameraDevice = null
        }
    }

    /**
     * Opens the camera
     * This never gets called unless we already have permissions.
     * We check again to satisfy Android requirements...
     */
    fun openCamera() {
        Timber.d("openCamera() called...")

        if (mCameraDevice != null) return

        mCameraManager = activity.getSystemService(Context.CAMERA_SERVICE) as CameraManager
        mCameraId = getRearFacingCamera()

        try {
            // Wait for camera to open - 2.5 seconds is "sufficient"
            if (!mCameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {
                throw RuntimeException("Time out waiting to lock camera opening.")
            }
            // check yet again for correct permissions and then OPEN the camera
            if (ContextCompat.checkSelfPermission(activity, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) {
                mCameraId?.also {
                    this.launch(this.coroutineContext) {
                        mCameraManager?.openCamera(it, mStateCallback, null)
                    }
                }
            }
        } catch (e: CameraAccessException) {
            Timber.e(e.toString())
        } catch (e: InterruptedException) {
            throw RuntimeException("Interrupted while trying to lock camera opening.", e)
        }
    }

    /**
     * Closes the current [CameraDevice].
     */
    fun closeCamera() {
        Timber.d("closeCamera() called...")

        try {
            mCameraOpenCloseLock.acquire()
            mCameraDevice?.close()
            mCameraDevice = null
        } catch (e: InterruptedException) {
            throw RuntimeException("Interrupted while trying to lock camera closing.", e)
        } finally {
            mCameraOpenCloseLock.release()
        }
    }

    /**
     * Get a [Range] of supported camera ISO values. The range may be NULL if the device
     * does not support manual ISO settings.
     * @return A [Range] of supported ISO values as [Integer]s
     */
    private fun getSupportedISOValues(): Range<Int>? {

        val isoValues = mCameraCharacteristics?.get(CameraCharacteristics.SENSOR_INFO_SENSITIVITY_RANGE)

        mMaxISO = isoValues?.upper
        mMinISO = isoValues?.lower

        return isoValues
    }

    /**
     * Get a [Range] of supported camera Exposure values. The range may be NULL if the device
     * does not support manual Exposure settings.
     * @return A [Range] of supported Exposure values as [Long]s
     */
    private fun getSupportedExposureValues(): Range<Long>? {

        val exposureValues = mCameraCharacteristics?.get(CameraCharacteristics.SENSOR_INFO_EXPOSURE_TIME_RANGE)

        mMaxExposure = exposureValues?.upper
        mMinExposure = exposureValues?.lower

        return exposureValues
    }

    /**
     * Get a [Range] of supported camera Exposure Compensation values. The range may be NULL if the device
     * does not support Exposure Compensation settings.
     * @return A [Range] of supported Exposure Compensation values as [Int]s
     */
    private fun getSupportedCompensationValues(): Range<Int>? {

        val compensationValues = mCameraCharacteristics?.get(CameraCharacteristics.CONTROL_AE_COMPENSATION_RANGE)

        mMaxCompensation = compensationValues?.upper
        mMinCompensation = compensationValues?.lower

        return compensationValues
    }

    /**
     *
     * @return
     */
    private fun getFocusCharacteristics(): IntArray? {

        return mCameraCharacteristics?.get(CameraCharacteristics.CONTROL_AF_AVAILABLE_MODES)
    }

    /**
     *
     * @return
     */
    private fun getFocusCapabilities(): String {

        val stringBuilder = StringBuilder()

        val cameraManager = activity.getSystemService(Context.CAMERA_SERVICE) as CameraManager
        val characteristics = cameraManager.getCameraCharacteristics("0")

        val minFocalDistance = characteristics.get(CameraCharacteristics.LENS_INFO_MINIMUM_FOCUS_DISTANCE)
        val hyperFocalDistance = characteristics.get(CameraCharacteristics.LENS_INFO_HYPERFOCAL_DISTANCE)

        minFocalDistance?.also {
            stringBuilder.append("Minimum Focus Distance: ")
            stringBuilder.append(minFocalDistance)
            stringBuilder.append("\n")
        }

        hyperFocalDistance?.also {
            stringBuilder.append("Maximum Focus Distance: ")
            stringBuilder.append(hyperFocalDistance)
            stringBuilder.append("\n")
        }

        return stringBuilder.toString()
    }

    /**
     *
     * @return
     */
    fun getCameraHardwareSupport(): String {

        val cameraManager = activity.getSystemService(Context.CAMERA_SERVICE) as CameraManager
        val characteristics = cameraManager.getCameraCharacteristics("0")

        var supportedHardwareLevel = SUPPORT_LEVEL_LEGACY
        when {
            characteristics.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL)
                    == CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_FULL ->
                supportedHardwareLevel = SUPPORT_LEVEL_FULL
            characteristics.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL)
                    == CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY ->
                supportedHardwareLevel = SUPPORT_LEVEL_LEGACY
            characteristics.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL)
                    == CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED ->
                supportedHardwareLevel = SUPPORT_LEVEL_LIMITED
        }
        return supportedHardwareLevel
    }

    /**
     *
     * @return
     */
    fun getCameraCapabilities(): String {

        val stringBuilder = StringBuilder()

        val cameraManager = activity.getSystemService(Context.CAMERA_SERVICE) as CameraManager
        val characteristics = cameraManager.getCameraCharacteristics("0")

        characteristics.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES)?.also {
            for (i in 0 until it.size) {
                when {
                    it[i] == CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE ->
                        stringBuilder.append("- BACKWARD_COMPATIBLE\n")
                    it[i] == CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING ->
                        stringBuilder.append("- MANUAL_POST_PROCESSING\n")
                    it[i] == CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR ->
                        stringBuilder.append("- MANUAL_SENSOR\n")
                    it[i] == CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_RAW ->
                        stringBuilder.append("- RAW\n")
                }
            }
        }
        return stringBuilder.toString()
    }

    /**
     * Finds the ID of the Rear facing camera
     * @return the ID of the Rear facing camera as a [String]
     */
    private fun getRearFacingCamera(): String? {

        var backCameraId: String? = null
        if (mCameraManager != null) {
            mCameraCharacteristics = mCameraManager?.getCameraCharacteristics("0")
            for (cameraId in (mCameraManager as CameraManager).cameraIdList) {
                val facing = mCameraCharacteristics?.get(CameraCharacteristics.LENS_FACING)
                if (facing != CameraMetadata.LENS_FACING_FRONT) {
                    backCameraId = cameraId
                    break
                }
            }
        }

        return backCameraId
    }

    // a good place to keep some constants
    companion object {
        const val REQUEST_CAMERA_PERMISSIONS = 0
        const val SUPPORT_LEVEL_LEGACY = "LEGACY"
        const val SUPPORT_LEVEL_LIMITED = "LIMITED"
        const val SUPPORT_LEVEL_FULL = "FULL"
    }
}